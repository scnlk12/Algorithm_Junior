# Algorithm_Junior
## 问题描述
输入 n (1< = n < = 10) 代表棋盘的规模是 n * n 的规模，骑士从某个点出发。骑士按象棋中“马走日”的行走方式，要求骑士走遍所有棋盘的格子（遍历棋盘的所有格子），输出骑士巡游整张棋盘的走法。

## 求解思路：
使用回溯法对问题进行求解，使用 DFS 暴力搜索出骑士从某个点出发的所有路径，所有的路径将构成一个解空间树。剪枝的方式是由于骑士从一个点行走有 8 个方向，若这 8 个方向都会出棋盘，或者走到已经走过的点上，则该点之下的解空间树必不存在可行解。

## 代码优化
如果能让骑士尽可能选择下一次可走的方向较少的坐标进行巡游（重排原理），则呈现的效果就是骑士先绕着棋盘的外围巡游，然后再逐层到棋盘的内层巡游。因为当骑士位于棋盘外围时，由于有棋盘的边界限制，会有大部分的方向直接处于不可走的状态。当骑士巡游到内层时，由于棋盘外层已经被巡游过了，可以认为是棋盘的大小收缩了，即外层变为了棋盘新的边界，使得骑士在内层巡游时仍然可以大量剪枝。

## 参考
https://www.cnblogs.com/linfangnan/p/14284202.html#677199593
